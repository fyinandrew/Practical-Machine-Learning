
<!DOCTYPE html>
<!-- saved from url=(0014)about:internet -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Predicting exercise from sensor data</title>

<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
   white-space: pre-wrap;
}

pre code {
   display: block; padding: 0.5em;
}

code.r, code.cpp {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}

</style>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: rgb(88, 72, 246)
   }

   pre .number {
     color: rgb(0, 0, 205);
   }

   pre .comment {
     color: rgb(76, 136, 107);
   }

   pre .keyword {
     color: rgb(0, 0, 255);
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: rgb(3, 106, 7);
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>




</head>

<body>
<h1>Predicting exercise from sensor data</h1>



<p>This is the review on the method I have used to build a model to predict exercise type using the Human Activity Data(see the section on the Weight Lifting Exercise Dataset)[1]. Model built has shown 0.42% OOB estimate of  error rate during training and 100% accuracy for validation and testing data.</p>

<h2>Preparation</h2>

<p>For this machine learning task, I decided to use caret and doMC(for parallelism).</p>

<pre><code class="r">library(caret)
library(doMC)
registerDoMC(cores=8)
</code></pre>

<h2>Preprocessing</h2>

<p>When looking at the training data in the spreadsheet, it was observed that many columns are empty or filled with many NAs. So I&#39;ve decided to delete such columns and wrote a function to do that easily.</p>

<pre><code class="r">training &lt;- read.csv(&quot;pml-training.csv&quot;)
testing &lt;- read.csv(&quot;pml-testing.csv&quot;)
remove_columns &lt;- function(df, cols_to_remove) {
  return(df[, -which(names(df) %in% cols_to_remove)])
}
</code></pre>

<p>First thing to remove was time related columns as they don&#39;t affect exercise class. Among them, new_window looked promising as it may signify the starting point of an exercise. But I&#39;ve decided to exclude it to start with simple features.</p>

<pre><code class="r">time_columns &lt;- c(&quot;raw_timestamp_part_1&quot;, 
                  &quot;raw_timestamp_part_2&quot;, 
                  &quot;cvtd_timestamp&quot;,  
                  &quot;new_window&quot;, 
                  &quot;num_window&quot;)
training &lt;- remove_columns(training, time_columns)
testing &lt;- remove_columns(testing, time_columns)
</code></pre>

<p>Next, columns without enough variance were deleted as such features are useless most of the time.</p>

<pre><code class="r">zero_columns &lt;- nearZeroVar(training)
training &lt;- training[, -zero_columns]
testing &lt;- testing[, -zero_columns]
</code></pre>

<p>When looking at NA columns, it was obvious that most of values are just NAs. For example, take a look at max_roll_dumbbell.</p>

<pre><code class="r">sum(is.na(training$max_roll_dumbbell))
</code></pre>

<pre><code>## [1] 19216
</code></pre>

<pre><code class="r">sum(!is.na(training$max_roll_dumbbell))
</code></pre>

<pre><code>## [1] 406
</code></pre>

<p>It means that imputation may not help as most of values in such columns will be filled with imputed values. So, columns with any NA were excluded.</p>

<pre><code class="r">na_columns &lt;- names(training)[which(
  sapply(names(training), function(col_name) { sum(is.na(training[, col_name])) != 0 }))]
training &lt;- remove_columns(training, na_columns)
testing &lt;- remove_columns(testing, na_columns)
</code></pre>

<p>Finally, I deleted columns with IDs. Testing data obviously had user_name in it. So, there&#39;s a room for building per user model, but I decided not to do that for the beginning.</p>

<pre><code class="r">id_columns &lt;- c(&quot;X&quot;, &quot;user_name&quot;)
training &lt;- remove_columns(training, id_columns)
testing &lt;- remove_columns(testing, id_columns)
</code></pre>

<h1>Model Building</h1>

<h2>Validation Data</h2>

<p>First thing to do was to take some of training data out as validation. (Note: I&#39;m using the term &#39;validation data&#39; to designate the data used for the verification of model before final prediction. This is the different definition of the &#39;validation data&#39; from the lecture but it&#39;s the definition used outside of the medical machine learning. See <a href="http://blogs.sas.com/content/jmp/2010/07/06/train-validate-and-test-for-data-mining-in-jmp/">Train, Validate and Test for Data Mining in JMP</a> as an example.) It would have been better if I had  done this in the beginning of the work. But I didn&#39;t use validation data very much during preprocessing anyway.</p>

<pre><code class="r">in_train &lt;- createDataPartition(training$classe, 
                                p=(NROW(training) - NROW(testing))/NROW(training), 
                                list=FALSE)
validation &lt;- training[-in_train, ]
training &lt;- training[in_train, ]
NROW(training)
</code></pre>

<pre><code>## [1] 19605
</code></pre>

<pre><code class="r">NROW(validation)
</code></pre>

<pre><code>## [1] 17
</code></pre>

<pre><code class="r">NROW(testing)
</code></pre>

<pre><code>## [1] 20
</code></pre>

<h2>Base Random Forest Model</h2>

<p>Random forest seemd to be appropriate for this task because of the following reasons:
1. Random forest usually shows good performance.
2. There are no NA in my data. (R&#39;s randomForest doesn&#39;t work with NAs).
3. Random forest captures interaction among variables which I didn&#39;t take care of in the pre-processing.</p>

<p>Even the first trial gave me satisfying result. (Note: seeds=NULL in trainControl() sets the seed to random integers automatically. Thanks to cache=TRUE chunk option in R Markdown, this seed set is preserved across the runs of the code.)</p>

<p>Here and the below, I have relied on the default trainControl() which uses 25 repetitions of bootstrapped samples for the purpose of cross validation like evaluation.</p>

<pre><code class="r">random_seed_control &lt;- trainControl(seeds=NULL)
rf_base &lt;- train(classe ~ ., data=training, method=&quot;rf&quot;, trControl=random_seed_control)
rf_base$results
</code></pre>

<pre><code>##   mtry Accuracy  Kappa AccuracySD  KappaSD
## 1    2   0.9934 0.9916  0.0009244 0.001168
## 2   27   0.9927 0.9908  0.0011918 0.001508
## 3   52   0.9857 0.9819  0.0033850 0.004279
</code></pre>

<h2>Downsampling Random Forest model</h2>

<p>Though the base model looked good, there was a problem in training$classes. Class &#39;A&#39; had more data than the others. Classifier built on such data is likely to predict &#39;A&#39; more often than the others, as it gives higher accuracy. </p>

<pre><code class="r">table(training$classe)
</code></pre>

<pre><code>## 
##    A    B    C    D    E 
## 5575 3794 3419 3213 3604
</code></pre>

<p>One can verify this by looking at the confusion matrix. Class &#39;A&#39; has lower errors than the others, meaning that classifier predicts data&#39;s class as &#39;A&#39; more often than the others.</p>

<pre><code class="r">rf_base$finalModel
</code></pre>

<pre><code>## 
## Call:
##  randomForest(x = x, y = y, mtry = param$mtry) 
##                Type of random forest: classification
##                      Number of trees: 500
## No. of variables tried at each split: 2
## 
##         OOB estimate of  error rate: 0.42%
## Confusion matrix:
##      A    B    C    D    E class.error
## A 5573    1    0    0    1   0.0003587
## B    9 3780    5    0    0   0.0036900
## C    0   14 3403    2    0   0.0046797
## D    0    0   44 3167    2   0.0143168
## E    0    0    0    5 3599   0.0013873
</code></pre>

<p>To address this, stratified sampling can be used. In this scheme, data is sampled from each strata (which is class) and the sample size for each class is the minimum of the number of data in all classes. In other words, we get min(table(training$classe)) samples from each class. This is called down sampling[2] as we sample less from classes with more data.</p>

<pre><code class="r">rf_strata &lt;- train(classe ~ ., data=training, method=&quot;rf&quot;, trControl=random_seed_control,
                   strata=training$classe, sampsize=rep(min(table(training$classe)), 5))
rf_strata$results
</code></pre>

<pre><code>##   mtry Accuracy  Kappa AccuracySD  KappaSD
## 1    2   0.9932 0.9913  0.0010537 0.001329
## 2   27   0.9931 0.9913  0.0009794 0.001236
## 3   52   0.9893 0.9864  0.0019394 0.002458
</code></pre>

<p>This new model has lower error for &#39;D&#39; but higher errors for others. Still, the overall OOB error rate stayed the same. It&#39;s 0.42% for both of rf_base and rf_strata.</p>

<pre><code class="r">rf_strata$finalModel
</code></pre>

<pre><code>## 
## Call:
##  randomForest(x = x, y = y, mtry = param$mtry, strata = ..1, sampsize = ..2) 
##                Type of random forest: classification
##                      Number of trees: 500
## No. of variables tried at each split: 2
## 
##         OOB estimate of  error rate: 0.42%
## Confusion matrix:
##      A    B    C    D    E class.error
## A 5570    4    0    0    1   0.0008969
## B    8 3779    7    0    0   0.0039536
## C    0   17 3401    1    0   0.0052647
## D    0    0   36 3175    2   0.0118270
## E    0    0    0    6 3598   0.0016648
</code></pre>

<h2>PCA</h2>

<p>Covariates are all numeric, thus it seemed like maybe PCA can help. To verify that, PCA preprocessing was applied.</p>

<pre><code class="r">rf_strata_pca &lt;- train(classe ~ ., data=training, method=&quot;rf&quot;, trControl=random_seed_control,
                       preProcess=&quot;pca&quot;,                         
                       strata=training$classe, sampsize=rep(min(table(training$classe)), 5))
rf_strata_pca$results
</code></pre>

<pre><code>##   mtry Accuracy  Kappa AccuracySD  KappaSD
## 1    2   0.9735 0.9664   0.002378 0.003001
## 2   27   0.9582 0.9472   0.004795 0.006048
## 3   52   0.9581 0.9470   0.004629 0.005837
</code></pre>

<p>But it&#39;s performance was lower than the previous two models.</p>

<h1>Validation</h1>

<p>To test the goodness of the models built so far, confusion matrices for validation data were calculated.</p>

<pre><code class="r">confusionMatrix(predict(rf_base, newdata=validation), validation$classe)$table
</code></pre>

<pre><code>##           Reference
## Prediction A B C D E
##          A 5 0 0 0 0
##          B 0 3 0 0 0
##          C 0 0 3 0 0
##          D 0 0 0 3 0
##          E 0 0 0 0 3
</code></pre>

<pre><code class="r">confusionMatrix(predict(rf_strata, newdata=validation), validation$classe)$table
</code></pre>

<pre><code>##           Reference
## Prediction A B C D E
##          A 5 0 0 0 0
##          B 0 3 0 0 0
##          C 0 0 3 0 0
##          D 0 0 0 3 0
##          E 0 0 0 0 3
</code></pre>

<pre><code class="r">confusionMatrix(predict(rf_strata_pca, newdata=validation), validation$classe)$table
</code></pre>

<pre><code>##           Reference
## Prediction A B C D E
##          A 5 0 0 0 0
##          B 0 3 0 0 0
##          C 0 0 3 0 0
##          D 0 0 0 3 0
##          E 0 0 0 0 3
</code></pre>

<p>All of them has shown the perfect performance.</p>

<h1>Testing</h1>

<p>Finally, predictions were made using the three models.</p>

<pre><code class="r">(p_base &lt;- predict(rf_base, newdata=testing))
</code></pre>

<pre><code>##  [1] B A B A A E D B A A B C B A E E A B B B
## Levels: A B C D E
</code></pre>

<pre><code class="r">(p_strata &lt;- predict(rf_strata, newdata=testing))
</code></pre>

<pre><code>##  [1] B A B A A E D B A A B C B A E E A B B B
## Levels: A B C D E
</code></pre>

<pre><code class="r">(p_strata_pca &lt;- predict(rf_strata_pca, newdata=testing))
</code></pre>

<pre><code>##  [1] B A A A A E D B A A B C B A E E A B B B
## Levels: A B C D E
</code></pre>

<pre><code class="r">all.equal(p_base, p_strata)
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<pre><code class="r">all.equal(p_base, p_strata_pca)
</code></pre>

<pre><code>## [1] &quot;1 string mismatch&quot;
</code></pre>

<p>As shown above, rf_base and rf_strata has shown the same results while PCA version has one different prediction. So I used the results from rf_base and rf_strata.</p>



</body>

</html>